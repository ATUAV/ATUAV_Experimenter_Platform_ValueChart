"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CreateObjectivesComponent = void 0;
// Import Angular Classes:
const core_1 = require("@angular/core");
const Observable_1 = require("rxjs/Observable");
require("../../utilities/rxjs-operators");
// Import Application Classes:
const services_1 = require("../../services");
const services_2 = require("../../services");
const services_3 = require("../../services");
const services_4 = require("../../services");
const services_5 = require("../../services");
const services_6 = require("../../services");
const ValueChartVis_1 = require("../../../ValueChartVis");
const ValueChartVis_2 = require("../../../ValueChartVis");
const model_1 = require("../../../model");
const model_2 = require("../../../model");
const model_3 = require("../../../model");
const model_4 = require("../../../model");
const model_5 = require("../../../model");
const model_6 = require("../../../model");
const model_7 = require("../../../model");
const model_8 = require("../../../model");
// Import Types:
const types_1 = require("../../../types");
const _ = require("lodash");
/*
    This component defines the UI controls for creating and editing the Objective structure of a ValueChart.
    It consists of an Angular table where each row is bound to an ObjectiveRow object (described at end of this file).
    Objectives are converted to/from ObjectiveRows when the component is created/destroyed.
*/
let CreateObjectivesComponent = /** @class */ (() => {
    let CreateObjectivesComponent = class CreateObjectivesComponent {
        // ========================================================================================
        // 									Constructor
        // ========================================================================================
        /*
            @returns {void}
            @description 	Used for Angular's dependency injection ONLY. It should not be used to do any initialization of the class.
                            This constructor will be called automatically when Angular constructs an instance of this class prior to dependency injection.
        */
        constructor(currentUserService, valueChartService, creationStepsService, updateValueChartService, validationService, userNotificationService, rendererScoreFunctionUtility) {
            this.currentUserService = currentUserService;
            this.valueChartService = valueChartService;
            this.creationStepsService = creationStepsService;
            this.updateValueChartService = updateValueChartService;
            this.validationService = validationService;
            this.userNotificationService = userNotificationService;
            this.rendererScoreFunctionUtility = rendererScoreFunctionUtility;
            // ========================================================================================
            // 									Fields
            // ========================================================================================
            this.ChartOrientation = types_1.ChartOrientation;
            this.Number = Number;
            this.ScoreFunction = model_6.ScoreFunction;
            this.services = {}; // Services container to pass to ScoreFunctionDirective
            // Default color palette for Primitive Objectives (generated by ColorBrewer 2.0 for 9 categorical variables).
            this.defaultColors = ['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00', '#ffff33', '#a65628', '#f781bf', '#999999'];
            // Add Category modal fields:
            this.categoryString = ''; // Comma-separated categories in modal textarea
            // Default Score Function modal fields:
            this.defaultScoreFunctionModalOpen = false;
            // Validation fields:
            this.validationTriggered = false; // Specifies whether or not validation has been triggered (this happens when the user attempts to navigate)
        }
        // ========================================================================================
        // 									Methods
        // ========================================================================================
        // ================================ Life-cycle Methods ====================================
        /*
            @returns {void}
            @description 	Initializes CreateObjectives. ngOnInit is only called ONCE by Angular.
                            Calling ngOnInit should be left to Angular. Do not call it manually.
        */
        ngOnInit() {
            this.creationStepsService.observables[this.creationStepsService.OBJECTIVES] = new Observable_1.Observable((subscriber) => {
                subscriber.next(this.validate());
                subscriber.complete();
            });
            this.services.chartUndoRedoService = new ValueChartVis_1.ChartUndoRedoService();
            this.services.rendererScoreFunctionUtility = this.rendererScoreFunctionUtility;
            this.objectiveRows = {};
            this.rootObjRowID = '0';
            this.objectivesCount = 0;
            this.editing = false;
            this.errorMessages = [];
            this.valueChart = this.valueChartService.getValueChart();
            if (this.valueChart.getAllObjectives().length === 0) {
                this.objectiveRows[this.rootObjRowID] = new ObjectiveRow(this.rootObjRowID, '', this.valueChart.getName(), this.valueChart.getDescription(), '', 0, 'abstract');
                this.objectivesCount++;
            }
            else {
                this.editing = true;
                let rootObjective = this.valueChart.getRootObjectives()[0];
                this.objectiveToObjRow(rootObjective, '', 0);
                this.validate();
            }
        }
        /*
            @returns {void}
            @description   Destroys CreateObjectives. ngOnDestroy is only called ONCE by Angular when the user navigates to a route which
                    requires that a different component is displayed in the router-outlet.
        */
        ngOnDestroy() {
            // Convert temporary structures to ValueChart structures
            this.valueChart.setRootObjectives([this.objRowToObjective(this.objectiveRows[this.rootObjRowID])]);
            if (this.editing) {
                this.updateValueChartService.cleanUpAlternatives(this.valueChart);
                for (let user of this.valueChart.getUsers()) {
                    let showWarnings = this.valueChart.isMember(this.currentUserService.getUsername()) && (this.currentUserService.getUsername() === user.getUsername());
                    let warnings = this.updateValueChartService.cleanUpUserPreferences(this.valueChart, user);
                    if (showWarnings) {
                        this.userNotificationService.displayWarnings(warnings);
                    }
                }
            }
        }
        // ================================ Objective Row Methods ====================================
        /*
            @returns {Array<string>}
            @description 	Gets all ObjectiveRow IDs.
        */
        objKeys() {
            return Object.keys(this.objectiveRows);
        }
        /*
            @returns {void}
            @description 	Creates a new, blank ObjectiveRow under an existing ObjectiveRow.
        */
        addNewChildObjRow(parentID, isGroup) {
            if (isGroup)
                this.addObjRow(parentID, new ObjectiveRow(String(this.objectivesCount), '', '', '', parentID, this.objectiveRows[parentID].depth + 1, 'abstract'));
            else
                this.addObjRow(parentID, new ObjectiveRow(String(this.objectivesCount), '', '', '', parentID, this.objectiveRows[parentID].depth + 1, 'primitive', this.getNextColor()));
            this.resetErrorMessages();
        }
        /*
            @returns {void}
            @description 	Inserts an ObjectiveRow under another ObjectiveRow.
        */
        addObjRow(parentID, objrow) {
            this.objectiveRows[objrow.id] = objrow;
            this.objectivesCount++;
            if (this.objectiveRows[parentID]) {
                this.objectiveRows[parentID].addChild(objrow.id);
            }
        }
        /*
            @returns {void}
            @description 	Deletes the ObjectiveRow with the given ID along with its children.
        */
        deleteObjRow(objID) {
            let parentID = this.objectiveRows[objID].parent;
            if (parentID !== '') {
                this.objectiveRows[parentID].removeChild(objID);
            }
            let children = this.objectiveRows[objID].children.slice();
            for (let child of children) {
                this.deleteObjRow(child);
            }
            delete this.objectiveRows[objID];
            this.resetErrorMessages();
        }
        /*
            @returns {void}
            @description 	Sets color of objrow based on its type.
        */
        setColor(objrow) {
            objrow.color = objrow.type === 'abstract' ? '' : this.getNextColor();
        }
        /*
            @returns {string}
            @description 	Gets next available color for objrow. Cycles through a list of defaults.
        */
        getNextColor() {
            let assignedColors = this.objKeys().map(key => this.objectiveRows[key].color);
            let availableColors = this.defaultColors.filter(color => assignedColors.indexOf(color) === -1);
            while (availableColors.length === 0) { // colors will be recycled
                this.defaultColors.forEach(color => assignedColors.splice(assignedColors.indexOf(color), 1)); // remove first instance of each color
                availableColors = this.defaultColors.filter(color => assignedColors.indexOf(color) === -1);
            }
            return availableColors[0];
        }
        /*
            @returns {boolean}
            @description 	Disable the "Edit" button in objID's row if the domain is not valid.
        */
        disableEditDefaultScoreFunction(objID) {
            let objrow = this.objectiveRows[objID];
            return this.objectiveRows[objID].type === 'abstract' || !this.objectiveRows[objID].dom.isValid();
        }
        /*
            @returns {void}
            @description 	Sets all default score functions to mutable if all are immutable, sets all to immutable otherwise.
        */
        toggleAllImmutable() {
            let allImmutable = this.allImmutable();
            for (let key of this.objKeys()) {
                if (this.objectiveRows[key].type === 'primitive') {
                    this.objectiveRows[key].defaultScoreFunction.immutable = !allImmutable;
                }
            }
        }
        /*
            @returns {boolean}
            @description 	Returns true iff all default score functions are immutable.
        */
        allImmutable() {
            if (this.objKeys().length === 0) {
                return false;
            }
            for (let key of this.objKeys()) {
                if (this.objectiveRows[key].type === 'primitive' && !this.objectiveRows[key].defaultScoreFunction.immutable) {
                    return false;
                }
            }
            return true;
        }
        /*
            @returns {string[]}
            @description 	Gets the ObjectiveRow IDs as a list in the order that they will be displayed.
        */
        getFlattenedObjectiveRows() {
            let flattened = [];
            this.flattenObjectiveRows([this.rootObjRowID], flattened);
            return flattened;
        }
        /*
            @returns {void}
            @description 	Recursively converts the implicit tree-structure of ObjectiveRows into a list in the order that the rows will be displayed.
        */
        flattenObjectiveRows(ObjectiveRowIDs, flattened) {
            for (let objID of ObjectiveRowIDs) {
                if (objID !== '0')
                    flattened.push(objID);
                this.flattenObjectiveRows(this.objectiveRows[objID].children, flattened);
            }
        }
        /*
            @returns {Objective}
            @description 	Converts an ObjectiveRow into an Objective.
        */
        objRowToObjective(objrow) {
            let obj;
            if (objrow.type === 'primitive') {
                obj = this.getObjectiveById(objrow.objid);
                if (obj === undefined) {
                    obj = new model_2.PrimitiveObjective('', '');
                }
                obj.setName(objrow.name);
                obj.setDescription(objrow.desc);
                objrow.objid = obj.getId();
                obj.setDomain(this.domainDetailsToDomain(objrow.dom));
                obj.setColor(objrow.color);
                if (!this.valueChart.isIndividual()) {
                    obj.setDefaultScoreFunction(objrow.defaultScoreFunction);
                }
            }
            else {
                obj = this.getObjectiveById(objrow.objid);
                if (obj === undefined) {
                    obj = new model_1.AbstractObjective('', '');
                }
                obj.setName(objrow.name);
                obj.setDescription(objrow.desc);
                objrow.objid = obj.getId();
                let subObjectives = [];
                for (let child of objrow.children) {
                    subObjectives.push(this.objRowToObjective(this.objectiveRows[child]));
                }
                obj.setDirectSubObjectives(subObjectives);
            }
            return obj;
        }
        getObjectiveById(id) {
            for (let obj of this.valueChartService.getValueChart().getAllObjectives()) {
                if (obj.getId() === id) {
                    return obj;
                }
            }
            return undefined;
        }
        /*
            @returns {Objective}
            @description 	Converts a DomainDetails object into a Domain.
        */
        domainDetailsToDomain(domDets) {
            let dom;
            if (domDets.type === 'categorical') {
                dom = new model_3.CategoricalDomain(true);
                for (let cat of domDets.elements) {
                    dom.addElement(cat);
                }
            }
            else if (domDets.type === 'interval') {
                dom = new model_5.IntervalDomain(domDets.min, domDets.max, domDets.interval);
            }
            else {
                if (domDets.unit) {
                    dom = new model_4.ContinuousDomain(domDets.min, domDets.max, domDets.unit);
                }
                else {
                    dom = new model_4.ContinuousDomain(domDets.min, domDets.max);
                }
            }
            return dom;
        }
        /*
            @returns {void}
            @description 	Recursively converts an Objective and all its descendants into ObjectiveRows.
        */
        objectiveToObjRow(obj, parentID, depth) {
            let objrow;
            if (obj.objectiveType === 'abstract') {
                objrow = new ObjectiveRow(String(this.objectivesCount), obj.getId(), obj.getName(), obj.getDescription(), parentID, depth, 'abstract');
                this.addObjRow(parentID, objrow);
                for (let child of obj.getDirectSubObjectives()) {
                    this.objectiveToObjRow(child, objrow.id, objrow.depth + 1);
                }
            }
            else {
                objrow = new ObjectiveRow(String(this.objectivesCount), obj.getId(), obj.getName(), obj.getDescription(), parentID, depth, 'primitive', obj.getColor(), this.domainToDomainDetails(obj.getDomain()), obj.getDefaultScoreFunction());
                objrow.latestDefault = this.getClosestDefault(obj);
                this.addObjRow(parentID, objrow);
            }
        }
        /*
            @returns {DomainDetails}
            @description 	Converts an Objective's Domain into DomainDetails (internal representation).
        */
        domainToDomainDetails(dom) {
            let domDets = new DomainDetails(dom.type);
            if (dom.type === 'categorical') {
                for (let cat of dom.getElements()) {
                    domDets.elements.push(cat);
                }
            }
            else if (dom.type === 'continuous') {
                domDets.min = dom.getMinValue();
                domDets.max = dom.getMaxValue();
                domDets.unit = dom.unit;
            }
            else {
                domDets.min = dom.getMinValue();
                domDets.max = dom.getMaxValue();
                domDets.interval = dom.getInterval();
                domDets.initializeIntervalDomainElements();
            }
            return domDets;
        }
        /*
            @returns {string}
            @description 	Returns the type of default (flat, positive linear, or negative linear) that is most similar to the current default score function.
        */
        getClosestDefault(obj) {
            let flatDiff = this.getDifference(obj.getInitialScoreFunction(model_6.ScoreFunction.FLAT), obj.getDefaultScoreFunction());
            let poslinDiff = this.getDifference(obj.getInitialScoreFunction(model_6.ScoreFunction.POSLIN), obj.getDefaultScoreFunction());
            let neglinDiff = this.getDifference(obj.getInitialScoreFunction(model_6.ScoreFunction.NEGLIN), obj.getDefaultScoreFunction());
            if (flatDiff <= poslinDiff && flatDiff <= neglinDiff) {
                return model_6.ScoreFunction.FLAT;
            }
            else {
                return poslinDiff <= neglinDiff ? model_6.ScoreFunction.POSLIN : model_6.ScoreFunction.NEGLIN;
            }
        }
        /*
            @returns {number}
            @description 	Returns the sum of the absolute difference between the element scores of two score functions.
                            (Assumes the score function elements are the same.)
        */
        getDifference(funcA, funcB) {
            if (!_.isEqual(funcA.getAllElements(), funcB.getAllElements())) {
                throw "Score function elements are not the same.";
            }
            let diff = 0;
            for (let elt of funcA.getAllElements()) {
                diff = diff + Math.abs(funcA.getScore(elt) - funcB.getScore(elt));
            }
            return diff;
        }
        // ================================ Categorical Domain Methods ====================================
        /*
            @returns {void}
            @description 	Updates categoryString to contain the categories for the selected Objective Row.
        */
        updateCategoryString() {
            this.categoryString = this.objectiveRows[this.selectedObjRow].dom.elements.join(', ');
        }
        /*
            @returns {void}
            @description 	Updates the categories for the selected Objective Row based on the categoryString.
        */
        updateCategories() {
            let editing = this.objectiveRows[this.selectedObjRow].dom.isValid();
            let categories = this.categoryString.split(',').map(cat => cat.trim());
            let uniqueCategories = categories.filter(function (elem, index, self) { return index === self.indexOf(elem); });
            this.objectiveRows[this.selectedObjRow].dom.elements = uniqueCategories;
            if (editing)
                this.updateCategoricalDefaultScoreFunction();
            else
                this.objectiveRows[this.selectedObjRow].initializeDefaultScoreFunction(false);
            this.resetErrorMessages();
        }
        /*
            @returns {void}
            @description 	Updates the default score function elements to reflect the domain elements for the selected Objective Row.
        */
        updateCategoricalDefaultScoreFunction() {
            let elementScoreMap = new Map();
            let elements = this.objectiveRows[this.selectedObjRow].dom.elements;
            let defaultScoreFunction = this.objectiveRows[this.selectedObjRow].defaultScoreFunction;
            for (let elt of elements) {
                if (defaultScoreFunction.getScore(elt) === undefined) {
                    elementScoreMap.set(elt, 0.5);
                    this.objectiveRows[this.selectedObjRow].defaultScoreFunctionModified = true;
                }
                else {
                    elementScoreMap.set(elt, defaultScoreFunction.getScore(elt));
                }
            }
            defaultScoreFunction.setElementScoreMap(elementScoreMap);
        }
        /*
            @returns {string[]}
            @description 	Gets selected elements of a given HTMLSelectElement.
        */
        getSelectedValues(select) {
            let result = [];
            let options = select && select.options;
            let opt;
            for (let i = 0, iLen = options.length; i < iLen; i++) {
                opt = options[i];
                if (opt.selected) {
                    result.push(opt.value || opt.text);
                }
            }
            return result;
        }
        // ================================ Validation Methods ====================================
        /*
            @returns {boolean}
            @description 	Checks validity of objectives structure in the chart.
        */
        validate() {
            this.validationTriggered = true;
            this.setErrorMessages();
            // Clean up references to Objectives
            this.updateValueChartService.cleanUpAlternatives(this.valueChart);
            for (let user of this.valueChart.getUsers()) {
                let showWarnings = this.valueChart.isMember(this.currentUserService.getUsername()) && (this.currentUserService.getUsername() === user.getUsername());
                let warnings = this.updateValueChartService.cleanUpUserPreferences(this.valueChart, user);
                if (showWarnings) {
                    this.userNotificationService.displayWarnings(warnings);
                }
            }
            return this.errorMessages.length === 0;
        }
        /*
            @returns {boolean}
            @description 	Converts ObjectiveRow structure into ValueChart objective, then validates the objective structure of the ValueChart.
        */
        setErrorMessages() {
            // Convert temporary structures to ValueChart structures
            this.valueChart.setRootObjectives([this.objRowToObjective(this.objectiveRows[this.rootObjRowID])]);
            // Validate
            this.errorMessages = this.validationService.validateObjectives(this.valueChart);
        }
        /*
            @returns {void}
            @description 	Resets error messages if validation has already been triggered.
                            (This is done whenever the user makes a change to the chart. This way, they get feedback while repairing errors.)
        */
        resetErrorMessages() {
            if (this.validationTriggered) {
                this.setErrorMessages();
            }
        }
    };
    CreateObjectivesComponent = __decorate([
        core_1.Component({
            selector: 'CreateObjectives',
            templateUrl: './CreateObjectives.template.html',
            providers: [ValueChartVis_2.RendererScoreFunctionUtility]
        }),
        __metadata("design:paramtypes", [services_5.CurrentUserService,
            services_2.ValueChartService,
            services_1.CreationStepsService,
            services_4.UpdateValueChartService,
            services_6.ValidationService,
            services_3.UserNotificationService,
            ValueChartVis_2.RendererScoreFunctionUtility])
    ], CreateObjectivesComponent);
    return CreateObjectivesComponent;
})();
exports.CreateObjectivesComponent = CreateObjectivesComponent;
/*
    This is an internal structure that is used to store the details of each Objective in the html table.
    Objectives are converted to/from ObjectiveRows when the component is created/destroyed.
    This is done so that ObjectiveRows can be converted between types while keeping the same object.
    It also allows us to store other useful properties (e.g. parent, depth) and makes Angular field binding simpler.
*/
class ObjectiveRow {
    constructor(id, objid, name, desc, parent, depth, type, color, dom, defaultScoreFunction) {
        this.id = id;
        this.objid = objid;
        this.name = name;
        this.desc = desc;
        this.parent = parent;
        this.depth = depth;
        this.type = type;
        color ? this.color = color : this.color = '';
        dom ? this.dom = dom : this.dom = new DomainDetails('categorical');
        this.children = [];
        this.latestDefault = model_6.ScoreFunction.FLAT;
        this.defaultScoreFunctionModified = false;
        defaultScoreFunction ? this.defaultScoreFunction = defaultScoreFunction : this.constructDefaultScoreFunction();
    }
    addChild(child) {
        this.children.push(child);
    }
    removeChild(child) {
        let i = this.children.indexOf(child);
        this.children.splice(i, 1);
    }
    changeDomType(newType) {
        let oldType = this.dom.type;
        this.dom.type = newType;
        if (!(oldType === 'interval' && this.dom.type === 'categorical')) {
            this.constructDefaultScoreFunction();
        }
    }
    constructDefaultScoreFunction() {
        let scoreFunction;
        if (this.dom.type === 'categorical' || this.dom.type === 'interval') {
            scoreFunction = new model_7.DiscreteScoreFunction();
        }
        else {
            scoreFunction = new model_8.ContinuousScoreFunction(this.dom.min, this.dom.max);
        }
        this.defaultScoreFunction = scoreFunction;
        this.initializeDefaultScoreFunction(false);
    }
    initializeDefaultScoreFunction(userTriggered) {
        if (this.dom.type === 'categorical') {
            this.defaultScoreFunction.initialize(this.latestDefault, this.dom.elements);
        }
        else if (this.dom.type === 'interval') {
            this.dom.initializeIntervalDomainElements();
            this.defaultScoreFunction.initialize(this.latestDefault, this.dom.elements);
        }
        else {
            this.defaultScoreFunction.setMinDomainValue(this.dom.min);
            this.defaultScoreFunction.setMaxDomainValue(this.dom.max);
            this.defaultScoreFunction.initialize(this.latestDefault);
        }
        if (!userTriggered) {
            this.defaultScoreFunctionModified = true;
        }
    }
    copy() {
        let domCopy = this.dom.copy();
        return new ObjectiveRow(this.id, this.objid, this.name, this.desc, this.parent, this.depth, this.type, this.color, domCopy, this.defaultScoreFunction);
    }
}
/*
    This class stores the details of an ObjectiveRow's domain.
    A single class covers all possible types so that ObjectiveRows can be converted between types while keeping the same object.
*/
class DomainDetails {
    constructor(type) {
        this.type = type;
        this.elements = [];
    }
    removeElement(cat) {
        let i = this.elements.indexOf(cat);
        this.elements.splice(i, 1);
    }
    initializeIntervalDomainElements() {
        this.elements = [];
        if (this.interval > 0) {
            let currentElement = this.min;
            while (currentElement < this.max) {
                this.elements.push('' + currentElement);
                currentElement += this.interval;
            }
            this.elements.push('' + this.max);
        }
    }
    isValid() {
        if (this.type === 'categorical') {
            return this.elements.length > 1;
        }
        else if (this.min !== undefined && !isNaN(this.min) && this.max !== undefined && !isNaN(this.max) && this.min < this.max) {
            return (this.type === 'continuous' || (this.interval > 0 && (this.max - this.min) % this.interval === 0));
        }
        return false;
    }
    copy() {
        let domCopy = new DomainDetails(this.type);
        domCopy.elements = this.elements.slice();
        domCopy.min = this.min;
        domCopy.max = this.max;
        domCopy.interval = this.interval;
        domCopy.unit = this.unit;
        return domCopy;
    }
}
//# sourceMappingURL=CreateObjectives.component.js.map